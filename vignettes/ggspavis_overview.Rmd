---
title: "ggspavis overview"
author: 
  - name: Lukas M. Weber
    affiliation: "Johns Hopkins Bloomberg School of Public Health, Baltimore, USA"
  - name: Helena L. Crowell
    affiliation: "University of Zurich, Zurich, Switzerland"
  - name: Yixing E. Dong
    affiliation: "University of Lausanne, Lausanne, Switzerland"
package: ggspavis
output: 
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{ggspavis overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

The `ggspavis` package contains a set of visualization functions for spatially resolved transcriptomics data, designed to work with the [SpatialExperiment](https://bioconductor.org/packages/SpatialExperiment) Bioconductor object class.

These plotting functions are used in our online book [OSTA](https://lmweber.org/OSTA-book/) and other work.

# Examples

Load some example datasets from the [STexampleData](https://bioconductor.org/packages/STexampleData) or [`spatialLIBD`](https://research.libd.org/spatialLIBD/) package, and a toy example data of a single-cell spatial CosMx data set. We create some example plots to demonstrate `ggspavis`.

```{r, message=FALSE, warning=FALSE}
library(SpatialExperiment)
library(STexampleData)
library(spatialLIBD)
# library(ggspavis)
source(here::here("R/plotSpots.R"))
source(here::here("R/plotVisium.R"))
source(here::here("R/plotQC.R"))
source(here::here("R/plotDimRed.R"))
source(here::here("R/utils.R"))
library(patchwork)
library(grid)

library(ggplot2)
library(ggside)
```

## 10x Genomics Visium: Mouse coronal brain section

First we start with a quick demo of the Visium mouse brain data. We perform the visualization of library size and gene expression level that can be easily derived. Both `plotVisium()` and `plotSpots()` reflects the spatial coordinates of spots, with the former overlays spots on the H&E image.

```{r, message=FALSE}
# load data in SpatialExperiment format
spe <- Visium_mouseCoronal()
rownames(spe) <- rowData(spe)$gene_name
colData(spe)$sum <- colSums(counts(spe))
```

With `plotVisium()` annotated by a continuous variable, you can adjust palette, legend.position, scaling of the variable, and whether to highlight spots that are in tissue, etc.

```{r, message=FALSE, warning=FALSE, fig.width=10, fig.height=4.5}
plotVisium(spe, annotate = "sum", highlight = "in_tissue", legend.position = "left") |
plotVisium(spe, annotate = "sum", highlight = "in_tissue", palette = "darkred")+
  guides(fill = guide_colorbar(title = "Libsize"))
```

`plotVisium()` can also be used to visualize gene expression.

```{r, fig.width=10, fig.height=4.5}
plotVisium(spe, annotate = "Gapdh", highlight = "in_tissue") | plotVisium(spe, annotate = "Mbp", highlight = "in_tissue")
```

Same for `plotSpots()`, and here for Visium we by default subset to spots that are in tissue. Palettes in `plotSpots()` can be changed like in `plotVisium()`.

```{r, fig.width=10, fig.height=4.5}
plotSpots(spe, annotate = "Gapdh") | plotSpots(spe, annotate = "Mbp", palette = "viridis")
```

`plotVisium()` and `plotSpots()` can also be used to visualize categorical variables, such as clusters on spatial coordinates with specified eight-level palettes (e.g. `libd_layer_colors` or `Okabe-Ito`) or NULL (for which the palette decision will be automated). We will introduce these functionality using Visium Human DLPFC data.

## 10x Genomics Visium: Human brain (DLPFC)
```{r, message=FALSE}
# load data in SpatialExperiment format
spe <- Visium_humanDLPFC()
rownames(spe) <- rowData(spe)$gene_name
colData(spe)$libsize <- colSums(counts(spe))
```

First, we check the ground truth annotation with the `spatialLIBD` palette, highlighting the spots that are in tissue.

```{r, message=FALSE, out.width="60%"}
plotVisium(spe, annotate = "ground_truth", highlight = "in_tissue", palette = "libd_layer_colors")
```

For `plotSpots()` on this Visium data, we leave the palette as NULL, and because "ground_truth" is categorical, eight distinct colors are generated. On the other hand, a NULL palette on a continuous variable means taking the default three-color gradient of "blue-beige-red".

```{r, fig.width=10, fig.height=4.5}
plotSpots(spe, annotate = "ground_truth") | plotSpots(spe, annotate = "libsize") + ggtitle("Library size")
```

We first derive some QC flags needed for plotting.

```{r}
## QC flags
spe <- scuttle::addPerCellQC(spe, subsets = list(mito = grepl("(^MT-)|(^mt-)", rowData(spe)$gene_name)))
spe$low_libsize <- spe$sum < 400 | spe$detected < 400
spe$high_mito <- spe$subsets_mito_percent > 30
```

In addition to `plotVisium()` and `plotSpots()`, `plotQC(type = "spots)` also reflects the spatial coordinates of the cells/spots, where cells/spots of interests should be labeled by a flag with TRUE or FALSE levels. The TRUE level are highlighted by red color.

We can check the spot with low library size on histogram and on spot spatially.

```{r, fig.width=10, fig.height=4.5}
plotQC(spe, metric_x = "sum", metric_y = "low_libsize", type = "hist") | 
  plotQC(spe, discard = "low_libsize", type = "spots")
```

We can also check the spot with high mitochondria percentage on histogram and on spot spatially.

```{r, fig.width=10, fig.height=4.5}
plotQC(spe, metric_x = "subsets_mito_percent", metric_y = "high_mito", type = "hist") | 
  plotQC(spe, discard = "high_mito", type = "spots")
```

We can also use scatterplot to check the trend between two variables. Below is a demonstration of how mitochondria percentage varies with library size. We can also highlight spots by putting some threshold on x and/or y axis. For example, spots with low library size but has high mitochondria percentage are of particular interest.

```{r, out.width="60%", warning=FALSE, message=FALSE}
plotQC(spe, type = "scatter", metric_x = "subsets_mito_percent", metric_y = "sum", threshold_x = 30, threshold_y = 400)
```

Now we can perform QC, library size log normalization, and simple clustering. The reduced dimension and clustering results are already stored in this `spe` object.

The same data set of `STexampleData::Visium_humanDLPFC()` is also stored in `spatialLIBD::fetch_data()`, but we use the `spatialLIBD` version for the already existing PCA and UMAP reduced dimensions stored in the `spe` object. The first step of `spatialLIBD::fetch_data()` will take some time.

```{r, message = FALSE, warning=FALSE}
# load data in SpatialExperiment format
spe <- spatialLIBD::fetch_data(type = "spe")
spe <- spe[, spe$sample_id == "151673"]
rownames(spe) <- rowData(spe)$gene_name
colData(spe)$libsize <- colSums(counts(spe))
```

We can compare the ground truth annotation with clustering result with `plotSpots()` (or `plotVisium()` overlaying H&E).

```{r, fig.width=10, fig.height=4.5}
spe$Cluster <- factor(spe$Cluster)
plotSpots(spe, annotate = "layer_guess_reordered") |
  plotSpots(spe, annotate = "Cluster")
```

We can now visualize the categorical clustering result or continuous gene expression value on UMAP with `plotDimRed()`

```{r, fig.width=8, fig.height=4, warning = FALSE}
plotDimRed(spe, type = "UMAP_neighbors15", annotate = "Cluster") | 
  plotDimRed(spe, type = "UMAP_neighbors15", annotate = "MBP")
```

Another example with `plotDimRed(type = "PCA")` on ground truth annotation, with text on each cluster, and another highly variable gene.

```{r, fig.width=8, fig.height=4}
plotDimRed(spe, type = "PCA", annotate = "layer_guess_reordered", text_by = "layer_guess_reordered_short") | 
  plotDimRed(spe, type = "PCA", annotate = "SCGB2A2")
```

## Nanostring CosMx: Human lung cancer

Now we demonstrate the usage of `ggspavis` on single-cell spatial technologies, such as Xenium, Vizgen, and CosMx. Here we start with reading in a toy example of CosMx data as a `SpatialExperiment` object.

```{r}
dir <- here::here("inst/extdata/NanostringCosMx/")
source(here::here("R/.readCosmxSPE.R"))
spe <- .readCosmxSPE(dirname = dir)
```

These single-cell spatial technologies usually do not come with an H&E image as Visium. Therefore, except `plotVisium()` which requires an image stored in the object, all other functions `plotSpots()`, `plotQC()`, `plotDimRed()` can be used as previously. Now the "spots" are the "cells".

Here we check the continuous cell area and gene expression level of KRT20.

```{r, fig.width=8, fig.height=2.5}
plotSpots(spe, annotate = "Area", in_tissue = NULL, show_axis = TRUE) | 
  plotSpots(spe, annotate = "KRT20", in_tissue = NULL, palette = "darkblue")
```

Same analysis on QC and dimension reduction could also be performed for your Xenium or Vizgen data as a `SpatialExperiment` object.

# Session information

```{r}
sessionInfo()
```
